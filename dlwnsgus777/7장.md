## 7장 - 데이터 암호화

---

**MySQL 5.7** 버전부터 지원되기 시작한 데이터 암호화 기능은 **MySQL 8.0** 으로 업그레이드 되면서

데이터 파일뿐만 아니라 리두 로그나 언두 로그, 복제를 위한 바이너리 로그 등도 모두 암호화 기능을 지원하기 시작했다.

데이터 암호화 여부는 보안 감사에서 필수적으로 언급되는 부분이며, 중요한 정보를 저장하는 서비스에서는

응용 프로그램에서 암호화한 데이터를 데이터베이스 서버에서 다시 암호화하는 이중 암호화 방법을 채택하기도 한다.

---

### MySQL 서버의 데이터 암호화

MySQL 서버의 암호화 기능은 데이터베이스 서버와 디스크 사이의 데이터를 읽고 쓰기 지점에서는 암호화 또는 복호화를 수행한다.

MySQL 서버에서 **디스크 입출력 이외의 부분에서는 암호화 처리가 전혀 필요하지 않다.**

즉, MySQL 서버(InnoDB 스토리지 엔진)의 **I/O 레이어에서만 데이터의 암호화 및 복호화 과정이 실행되는 것이다.**

데이터 암호화 기능이 활성화돼 있다고 하더라고 MySQL 내부와 사용자 입장에서는 아무런 차이가 없기 때문에

이러한 암호화 방식을 가르켜 **TDE(Transparent Data Encrytion)** 이라고 한다.

또한 **Data at Rest Encrytion** 이라고도 하는데 메모리나 네트워크 전송 단계가 아닌

**디스크에 저장된 단계에서만 암호화된다는 의미** 로 사용되는 표현이다.

### 2단계 키관리

MySQL 서버의 TDE에서 암호화 키는 키링 플러그인에 의해 관리되며 MySQL 8.0 버전에서 지원되는 키링 플러그인은 다음과 같다.

- keyring_file : FILE - Based 플러그인
- keyring_encrypted_file : Keyring 플러그인
- keyring_okv : KMIP 플러그인
- keyting_aws : Amazon Web Services Keyring 플러그인

**MySQL 커뮤니티 에디션** 에서는 `keyring_file` 플러그인만 사용이 가능하다.

하지만 마스터 키를 관리하는 방법만 다를 뿐 **MySQL 서버 내부적으로 작동하는 방식은 모두 동일하다.**

MySQL 서버의 키링 플러그인은 **2단계 (2-Tier)** 키 관리 방식을 사용한다.

MySQL 서버의 데이터 암호화는 **마스터 키** 와 **테이블스페이스 키** 라는 두 가지 종류의 키를 가지고 있는데

테이블스페이스 키는 프라이빗 키라고도 한다.

MySQL 서버는 플러그인을 사용해 마스터 키를 가져오고 **암호화된 테이블이 생성될 때마다 해당 테이블을 위한 임의의 테이블스페이스 키를 발급한다.**

그리고 마스터 키를 이용해 테이블스페이스 키를 암호화해서 각 테이블 데이터 파일 헤더에 저장한다.

**테이블스페이스 키는 절대 MySQL 서버 외부로 노출되지 않기 때문에** 주기적으로 변경하지 않아도 보안상 취약점이 되지 않는다.

**마스터 키는 외부의 파일을 이용하기 때문에 노출될 가능성이 있다.**

때문에 마스터키는 주기적으로 변경해야 하는데 다음 명령어를 통해 변경할 수 있다.

```
ALTER INSTANCE ROTATE INNODB MASTER KEY;
```

**마스터 키를 변경하면 기존의 마스터 키를 이용해 각 테이블의 테이블스페이스 키를 복호화한 다음 새로운 마스터 키로 다시 암호화한다.**

마스터 키가 변경되는 동안 테이블스페이스 키 자체와 데이터 파일의 데이터는 전혀 변경되지 않는다.

MySQL 서버에서는 이렇게 2단계 암호화 방식을 사용해 암호화 키 변경으로 인한 과도한 시스템 부하를 피한다.

MySQL 서버의 TDE 에서 지원되는 암호화 알고리즘은 **AES 256비트** 이며 이외의 알고리즘은 지원되지 않는다.

테이블스페이스 키는 **AES-256 ECB** 알고리즘을 이용해 암호화되고,

실제 데이터 파일은 **AES-256 CBC** 알고리즘을 이용해 암호화된다.

### 암호화와 성능

MySQL 서버의 암호화는 TDE 방식이기 때문에 디스크로부터 한 번 읽은 데이터 페이지는 **복호화되어 InnoDB의 버퍼 풀에 적재된다.**

그래서 데이터 페이지가 한 번 메모리에 적재되면 **암호화되지 않은 테이블과 동일한 성능** 을 보인다.

하지만 쿼리가 InnoDB의 버퍼 풀에 존재하지 않는 페이지를 읽어야 한다면 복호화 과정을 거치기 때문에

복호화 시간 동안 쿼리 처리가 **지연** 될 것이다.

암호화된 테이블이 변경되면 다시 디스크로 동기화될 때 암호화돼야 하기 때문에 **디스크 저장** 할 때도 추가로 시간이 걸린다.

하지만 데이터 페이지 저장은 사용자의 쿼리를 처리하는 스레드가 아닌 MySQL 서버의 **백그라운드 스레드** 가 수행하기 때문에

실제 사용자 쿼리가 지연되는 것은 아니다.

`SELECT`, `UPDATE`, `DELETE` 명령은 레코드를 InnoDB 버퍼 풀로 읽어와야 하기 때문에

새롭게 디스크에서 읽어야 하는 데이터 페이지의 개수에 따라 복호화 지연이 발생한다.
